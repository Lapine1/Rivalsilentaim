-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Load Orion Library
local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/shlexware/Orion/main/source')))()

-- Create Window
local Window = OrionLib:MakeWindow({Name = "Lapines Silent", HidePremium = false, SaveConfig = true, ConfigFolder = "YourConfigFolder"})

-- Variables
_G.silentAimActive = true
_G.chamsActive = true
_G.FOVEnabled = false
_G.FOVSize = 100
_G.chamsVisibleColor = Color3.new(0, 0, 1) -- Default visible color (blue)
_G.chamsHiddenColor = Color3.new(1, 0, 0) -- Default hidden color (red)
_G.hitChance = 100 -- Default 100% hit chance
_G.noclipActive = false
_G.longJumpActive = false
_G.longJumpPower = 50 -- Default power for the long jump
_G.longJumpModes = {
    ["Legit"] = 50,
    ["Insane"] = 100,
    ["Rage"] = 200
}

-- FOV Circle setup
local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 2
FOVCircle.Color = Color3.fromRGB(255, 255, 255)
FOVCircle.Filled = false
FOVCircle.Transparency = 1
FOVCircle.Visible = false

-- Chams setup
local chamsFolder = Instance.new("Folder")
chamsFolder.Name = "ChamsFolder"
chamsFolder.Parent = game.CoreGui

-- Function to update FOV Circle position
local function updateFOVCircle()
    if _G.FOVEnabled then
        FOVCircle.Position = UserInputService:GetMouseLocation()
        FOVCircle.Radius = _G.FOVSize
    end
    FOVCircle.Visible = _G.FOVEnabled
end

-- Function to get the nearest target's head within FOV
local function getNearestHead()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local mousePos = UserInputService:GetMouseLocation()

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Head") then
            local headPos = Camera:WorldToViewportPoint(player.Character.Head.Position)
            local distance = (Vector2.new(headPos.X, headPos.Y) - mousePos).Magnitude

            if distance < shortestDistance and distance <= _G.FOVSize then
                shortestDistance = distance
                closestPlayer = player
            end
        end
    end

    if closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild("Head") then
        return closestPlayer.Character.Head
    end

    return nil
end

-- Silent aim functionality with headshots and hit chance
UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 and _G.silentAimActive then
        if math.random(1, 100) <= _G.hitChance then
            local targetHead = getNearestHead()
            if targetHead then
                local aimPosition = targetHead.Position
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, aimPosition)
                ReplicatedStorage.Remotes.Attack:FireServer(targetHead)
            end
        end
    end
end)

-- Updated Chams function
local function updateChams()
    if _G.chamsActive then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local highlight = chamsFolder:FindFirstChild(player.Name) or Instance.new("Highlight")
                highlight.Name = player.Name
                highlight.Parent = chamsFolder
                highlight.Adornee = player.Character
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                highlight.OutlineTransparency = 0

                -- Check visibility
                local character = player.Character
                local head = character:FindFirstChild("Head")
                if head then
                    local rayParams = RaycastParams.new()
                    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}

                    local rayResult = workspace:Raycast(Camera.CFrame.Position, (head.Position - Camera.CFrame.Position).Unit * 1000, rayParams)
                    
                    if rayResult and rayResult.Instance:IsDescendantOf(character) then
                        -- Visible
                        highlight.FillColor = _G.chamsVisibleColor
                        highlight.FillTransparency = 0.5
                    else
                        -- Behind wall
                        highlight.FillColor = _G.chamsHiddenColor
                        highlight.FillTransparency = 0.25
                    end
                end
            end
        end
    else
        chamsFolder:ClearAllChildren()
    end
end

-- Main loop
RunService.RenderStepped:Connect(function()
    updateFOVCircle()
    updateChams()
    -- Any continuous silent aim logic can go here if needed
end)

-- Create tabs
local PlayerTab = Window:MakeTab({Name = "Player", Icon = "rbxassetid://4483345998", PremiumOnly = false})
local SilentAimTab = Window:MakeTab({Name = "Silent Aim", Icon = "rbxassetid://4483345998", PremiumOnly = false})
local ChamsTab = Window:MakeTab({Name = "Chams", Icon = "rbxassetid://4483345998", PremiumOnly = false})

-- Player tab (Corrected Noclip functionality)
PlayerTab:AddBind({
    Name = "Noclip",
    Default = Enum.KeyCode.V,
    Hold = false,
    Callback = function()
        _G.noclipActive = not _G.noclipActive
        if _G.noclipActive then
            activateNoclip()
        else
            disableNoclip()
        end
    end,
    Flag = "NoclipKey",
    Save = true
})

local function activateNoclip()
    local player = LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()

    local function updateNoclip()
        if _G.noclipActive and character:IsDescendantOf(game.Workspace) then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end

    RunService:BindToRenderStep("Noclip", 100, updateNoclip)
end

-- Cleanup function for noclip
local function disableNoclip()
    RunService:UnbindFromRenderStep("Noclip")
    local character = LocalPlayer.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

-- Connect the cleanup function
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    if _G.noclipActive then
        activateNoclip()
    end
end)

-- New Fly Section
PlayerTab:AddSection({
    Name = "Enable Fly"
})

-- Fly keybind and functionality
local flyActive = false
local flySpeed = 50

PlayerTab:AddBind({
    Name = "Toggle Fly",
    Default = Enum.KeyCode.F,
    Hold = false,
    Callback = function()
        flyActive = not flyActive
        local player = LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:WaitForChild("Humanoid")
        local rootPart = character:WaitForChild("HumanoidRootPart")

        if flyActive then
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyVelocity.Parent = rootPart
            bodyVelocity.Name = "FlyVelocity"

            RunService:BindToRenderStep("Fly", 100, function()
                if flyActive then
                    local camera = Workspace.CurrentCamera
                    local moveDirection = camera.CFrame:VectorToWorldSpace(
                        Vector3.new(
                            UserInputService:IsKeyDown(Enum.KeyCode.D) and 1 or (UserInputService:IsKeyDown(Enum.KeyCode.A) and -1 or 0),
                            UserInputService:IsKeyDown(Enum.KeyCode.Space) and 1 or (UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) and -1 or 0),
                            UserInputService:IsKeyDown(Enum.KeyCode.S) and 1 or (UserInputService:IsKeyDown(Enum.KeyCode.W) and -1 or 0)
                        )
                    )
                    bodyVelocity.Velocity = moveDirection * flySpeed
                end
            end)
        else
            RunService:UnbindFromRenderStep("Fly")
            local bodyVelocity = rootPart:FindFirstChild("FlyVelocity")
            if bodyVelocity then
                bodyVelocity:Destroy()
            end
        end
    end,
    Flag = "FlyKey",
    Save = true
})

-- Fly Speed Slider
PlayerTab:AddSlider({
    Name = "Fly Speed",
    Min = 1,
    Max = 200,
    Default = 50,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    ValueName = "Speed",
    Callback = function(Value)
        flySpeed = Value
    end    
})

-- Silent Aim tab
SilentAimTab:AddToggle({
    Name = "Toggle Silent Aim",
    Default = true,
    Callback = function(Value)
        _G.silentAimActive = Value
    end    
})

-- Hit Chance Slider
SilentAimTab:AddSlider({
    Name = "Hit Chance",
    Min = 0,
    Max = 100,
    Default = 100,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    ValueName = "%",
    Callback = function(Value)
        _G.hitChance = Value
    end    
})

-- Add separator (just text)
SilentAimTab:AddLabel("FOV")

-- FOV Circle toggle
SilentAimTab:AddToggle({
    Name = "Show FOV Circle",
    Default = false,
    Callback = function(Value)
        _G.FOVEnabled = Value
    end    
})

-- FOV Circle size slider
SilentAimTab:AddSlider({
    Name = "FOV Circle Size",
    Min = 50,
    Max = 500,
    Default = 100,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    ValueName = "pixels",
    Callback = function(Value)
        _G.FOVSize = Value
    end    
})

-- Chams tab
ChamsTab:AddToggle({
    Name = "ToggleChams",
    Default = true,
    Callback = function(Value)
        _G.chamsActive = Value
        if not Value then
            chamsFolder:ClearAllChildren()
        end
    end    
})

-- Visible Chams Color Picker
ChamsTab:AddColorpicker({
    Name = "Visible Chams Color",
    Default = Color3.new(0, 0, 1),
    Callback = function(Value)
        _G.chamsVisibleColor = Value
    end
})

-- Hidden Chams Color Picker
ChamsTab:AddColorpicker({
    Name = "Hidden Chams Color",
    Default = Color3.new(1, 0, 0),
    Callback = function(Value)
        _G.chamsHiddenColor = Value
    end
})

-- Jumps Section
PlayerTab:AddSection({
    Name = "Jumps"
})

-- Infinite Jump
local infiniteJumpActive = false
local jumpConnection

PlayerTab:AddToggle({
    Name = "Infinite Jump",
    Default = false,
    Callback = function(Value)
        infiniteJumpActive = Value
        
        if infiniteJumpActive then
            local function infiniteJump()
                local player = LocalPlayer
                local character = player.Character
                if character and character:FindFirstChildOfClass("Humanoid") then
                    -- Check if the humanoid is already jumping to avoid unnecessary state changes
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then
                        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    end
                end
            end

            -- Connect the JumpRequest event if not already connected
            if not jumpConnection then
                jumpConnection = UserInputService.JumpRequest:Connect(function()
                    if infiniteJumpActive then
                        infiniteJump()
                    end
                end)
            end
        else
            -- Disconnect the JumpRequest event when infinite jump is turned off
            if jumpConnection then
                jumpConnection:Disconnect()
                jumpConnection = nil
            end
        end
    end    
})

-- Long Jump
local longJumpActive = false
local longJumpPower = 50 -- Default power for the long jump
local longJumpModes = {
    ["Legit"] = 50,
    ["Insane"] = 100,
    ["Rage"] = 200
}

PlayerTab:AddToggle({
    Name = "Long Jump",
    Default = false,
    Callback = function(Value)
        _G.longJumpActive = Value
        
        if _G.longJumpActive then
            -- Set up long jump behavior
            local function performLongJump()
                local player = LocalPlayer
                local character = player.Character
                if character and character:FindFirstChildOfClass("Humanoid") then
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    humanoid:ChangeState(Enum.HumanoidStateType.Physics)
                    local rootPart = character:FindFirstChild("HumanoidRootPart")
                    if rootPart then
                        rootPart.Velocity = rootPart.CFrame.LookVector * _G.longJumpPower
                    end
                end
            end

            -- Bind to RenderStepped for continuous long jump checks
            RunService:BindToRenderStep("LongJump", 100, function()
                if _G.longJumpActive then
                    performLongJump()
                end
            end)
        else
            -- Unbind the LongJump function when turned off
            RunService:UnbindFromRenderStep("LongJump")
        end
    end    
})

-- Long Jump Mode Dropdown
PlayerTab:AddDropdown({
    Name = "Long Jump Mode",
    Default = "Legit",
    Options = {"Legit", "Insane", "Rage"},
    Callback = function(selectedMode)
        _G.longJumpPower = _G.longJumpModes[selectedMode] or 50
    end
})

-- Initialize Orion Library
OrionLib:Init()
